# -*- coding: utf-8 -*-"""Created on Fri Nov 10 13:20:47 2024@author: Maksymilian SkibaThis code compares the evolution of a quantum system interacting with ancillary states, with and without applying uncomputation, following the method from the Uncompute_GHZ model."""import numpy as npimport matplotlib.pyplot as pltimport timestart = time.time()# Define basic states and constantsa = np.array([0, 0, 1])b1 = np.array([0, 1, 0])b2 = np.array([1, 0, 0])# Function to create a unitary matrix that acts on m, k, l statesdef U_mkl(m, k, l, phi, theta):    return (np.cos(theta) * np.outer(k, k)) + (np.cos(theta) * np.outer(l, l)) + \           (np.exp(1j * phi) * np.sin(theta) * np.outer(k, l)) - \           (np.exp(-1j * phi) * np.sin(theta) * np.outer(l, k)) + np.outer(m, m)# Function to create a random unitary matrix using QR decompositiondef random_unitary(seed=None):    if seed is not None:        np.random.seed(seed)    random_matrix = np.random.randn(4, 4) + 1j * np.random.randn(4, 4)    q, _ = np.linalg.qr(random_matrix)  # QR decomposition to create a unitary matrix    return q# Pauli matrices for measurementspauli_z = np.array([[1, 0], [0, -1]])# Initial conditionsdt = 0.1U = np.cos(dt) * pauli_y - np.sin(dt) * pauli_z  # Random unitary for evolutionsys_state = np.array([1, 0])state_initial = (1/np.sqrt(2)) * (np.kron([1, 0], [1, 0]) + np.kron([0, 1], [0, 1]))  # Initial state of the system and ancillaphi_init = 0theta_init = np.pi / 4len_states = 10# Data collection for plottingwith_uncompute_data = []without_uncompute_data = []steps = np.arange(1, len_states + 1, step=1)# Define the function to calculate the expectation value of Pauli Zdef calculate_expectation(state, pauli_z):    rho = np.outer(state, np.conjugate(state))    current_dims = [2, state.shape[0] // 2]    try:        rho_reshaped = rho.reshape(current_dims + current_dims)        sys_rho = np.trace(rho_reshaped, axis1=1, axis2=3)        exp_sig = np.trace(np.dot(sys_rho, pauli_z)).real        return exp_sig    except ValueError as e:        print(f"Error in reshaping: {e}")        return None# Case 1: Evolution with Uncomputation (using SVD)state = state_initialfor i in range(len_states):    # Apply unitary evolution    if i == 0:        U_i = np.kron(np.eye(2), U_mkl(b1, a, b2, phi_init, theta_init))    else:        U_i = np.kron(np.eye(2), np.cos(dt) * pauli_y - np.sin(dt) * pauli_z)  # Random unitary expanded to match dimensions    state = np.dot(U_i, state)    # Uncompute using SVD to disentangle the ancillary states    state_reshaped = state.reshape(2, -1)  # Assuming 3-dimensional system and ancillary part    U_svd, s, Vh_svd = np.linalg.svd(state_reshaped, full_matrices=False)    state = np.dot(U_svd, np.dot(np.diag(s), Vh_svd))  # Reconstruct to disentangle ancilla    state = state.flatten()  # Flatten back to the original shape    # Calculate and store the expectation value    exp_sig = calculate_expectation(state, pauli_z)    if exp_sig is not None:        with_uncompute_data.append(exp_sig)# Case 2: Evolution without Uncomputation (still using SVD)state = state_initialfor i in range(len_states):    # Apply unitary evolution    if i == 0:        U_i = np.kron(np.eye(3), U_mkl(b1, a, b2, phi_init, theta_init))    else:        U_i = np.kron(np.eye(3), np.cos(dt) * pauli_y - np.sin(dt) * pauli_z)  # Random unitary expanded to match dimensions    state = np.dot(U_i, state)    # Perform SVD but do not use the conjugate unitary to uncompute    state_reshaped = state.reshape(3, -1)  # Assuming 3-dimensional system and ancillary part    U_svd, s, Vh_svd = np.linalg.svd(state_reshaped, full_matrices=False)    state = np.dot(U_svd, np.dot(np.diag(s), Vh_svd))  # Reconstruct to disentangle ancilla    state = state.flatten()  # Flatten back to the original shape    # Calculate and store the expectation value    exp_sig = calculate_expectation(state, pauli_z)    if exp_sig is not None:        without_uncompute_data.append(exp_sig)# Plot the evolution of the system with and without uncomputationfig, ax = plt.subplots(figsize=(10, 6))ax.plot(steps[:len(with_uncompute_data)], with_uncompute_data, label="With Uncompute (SVD)", color="blue", linewidth=2)ax.plot(steps[:len(without_uncompute_data)], without_uncompute_data, label="Without Uncompute (SVD)", color="red", linestyle='--', linewidth=2)ax.set_title("Evolution of system with and without Uncompute (SVD)", fontsize=16, pad=15)ax.set_xlabel("Steps (collision with ith ancilla)", fontsize=14)ax.set_ylabel("Expectation value", fontsize=14)ax.grid(True, which='both', linestyle='--', linewidth=0.5)ax.legend(loc='upper right', fontsize=12, frameon=True)ax.tick_params(axis='both', which='major', labelsize=12)plt.tight_layout()plt.show()